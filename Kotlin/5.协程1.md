---

title: 5.协程

date: 2021-01-28

categories: 
   - Kotlin

tags: 
   - Kotlin 

description: ​
---


# 简单理解

进程是什么呢？

直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。

进程拥有代码和打开的文件资源、数据资源、独立的内存空间。

线程又是什么呢？

线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。

线程拥有自己的栈空间。


![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/process.jpeg)


对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。

无论进程还是线程，都是由操作系统所管理的。

Java中线程具有五种状态：

* 初始化

* 可运行

* 运行中

* 阻塞

* 销毁

这五种状态的转化关系如下：

![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/thread_state.png)

但是，线程不同状态之间的转化是谁来实现的呢？是JVM吗？

并不是。JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程的状态，这一过程需要耗费一定的CPU资源。


线程, 
1. 涉及到同步锁。

2. 涉及到线程阻塞状态和可运行状态之间的切换。

3. 涉及到线程上下文的切换。

以上涉及到的任何一点，都是非常耗费性能的操作。


什么是协程

协程，英文Coroutines，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。


![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/coroutine.jpeg)


最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。

这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。


# 协程概念


* 特征：协程是运行在单线程中的并发程序

* 优点：省去了传统 Thread 多线程并发机制中切换线程时带来的线程上下文切换、线程状态切换、Thread 初始化上的性能损耗，能大幅度唐提高并发性能

* 简单理解：在单线程上由程序员自己调度运行的并行计算

下面是关于协程这个概念的一些描述：

> 协程的开发人员 Roman Elizarov 是这样描述协程的：协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。

> Coroutine，翻译成”协程“，初始碰到的人马上就会跟进程和线程两个概念联系起来。直接先说区别，Coroutine是编译器级的，Process和Thread是操作系统级的。Coroutine的实现，通常是对某个语言做相应的提议，然后通过后成编译器标准，然后编译器厂商来实现该机制。Process和Thread看起来也在语言层次，但是内生原理却是操作系统先有这个东西，然后通过一定的API暴露给用户使用，两者在这里有不同。Process和Thread是os通过调度算法，保存当前的上下文，然后从上次暂停的地方再次开始计算，重新开始的地方不可预期，每次CPU计算的指令数量和代码跑过的CPU时间是相关的，跑到os分配的cpu时间到达后就会被os强制挂起。Coroutine是编译器的魔术，通过插入相关的代码使得代码段能够实现分段式的执行，重新开始的地方是yield关键字指定的，一次一定会跑到一个yield对应的地方

> 对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。协程能保留上一次调用时的状态，不需要像线程一样用回调函数，所以性能上会有提升。缺点是本质是个单线程，不能利用到单个CPU的多个核

# 协程和线程的对比：

1. Thread - 线程拥有独立的栈、局部变量，基于进程的共享内存，因此数据共享比较容易，但是多线程时需要加锁来进行访问控制，不加锁就容易导致数据错误，但加锁过多又容易出现死锁。线程之间的调度由内核控制(时间片竞争机制)，程序员无法介入控制(即便我们拥有sleep、yield这样的API，这些API只是看起来像，但本质还是交给内核去控制，我们最多就是加上几个条件控制罢了)，线程之间的切换需要深入到内核级别，因此线程的切换代价比较大，表现在：
* 线程对象的创建和初始化
* 线程上下文切换
* 线程状态的切换由系统内核完成
* 对变量的操作需要加锁



![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/process.jpeg)


2. Coroutine 协程是跑在线程上的优化产物，被称为轻量级 Thread。传统 Thread 执行的核心是一个while(true) 的函数，本质就是一个耗时函数，Coroutine 可以用来直接标记方法，由程序员自己实现切换，调度，不再采用传统的时间段竞争机制。在一个线程上可以同时跑多个协程，同一时间只有一个协程被执行，在单线程上模拟多线程并发，协程何时运行，何时暂停，都是有程序员自己决定的，使用： yield/resume API，优势如下：

* 因为在同一个线程里，协程之间的切换不涉及线程上下文的切换和线程状态的改变，不存在资源、数据并发，所以不用加锁，只需要判断状态就OK，所以执行效率比多线程高很多
* 协程是非阻塞式的(也有阻塞API)，一个协程在进入阻塞后不会阻塞当前线程，当前线程会去执行其他协程任务




# Kotlin 中的协程

总结下，协程是跑在线程上的，一个线程可以同时跑多个协程，每一个协程则代表一个耗时任务，我们手动控制多个协程之间的运行、切换，决定谁什么时候挂起，什么时候运行，什么时候唤醒，而不是 Thread 那样交给系统内核来操作去竞争 CPU 时间片

协程在线程中是顺序执行的，既然是顺序执行的那怎么实现异步，这自然是有手段的。Thread 中我们有阻塞、唤醒的概念，协程里同样也有，挂起等同于阻塞，区别是 Thread 的阻塞是会阻塞当前线程的(此时线程只能空耗 cpu 时间而不能执行其他计算任务，是种浪费)，而协程的挂起不会阻塞线程。当线程接收到某个协程的挂起请求后，会去执行其他计算任务，比如其他协程。协程通过这样的手段来实现多线程、异步的效果，在思维逻辑上同 Thread 的确有比较大的区别，大家需要适应下思路上的变化
