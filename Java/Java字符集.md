---

title: Java字符集

date: 2019-07-03

categories: 
   - Java
   - 泛型

tags: 
   - Java
   - 泛型 


description: 
​
---

<!-- TOC -->

- [Java字符集](#java字符集)

<!-- /TOC -->

# Java字符集



输出文件， 一般new  FileOutputStream的 都会自动创建。

但是输入文件， 都要自己创建， 要么手动创建， 要么使用方法  file.create 创建





decoder：解码。将文件（字节流）转成成人能看懂的字符串。

encoder：编码。将字符、字符串转成字节数组



字符、字符串都是字节的一种表示形式（编码方式）

真正存储的都是字节。



存储在磁盘的文件， 都是有一种编码的。  IDEA 默认UTF-8

实质上在磁盘上存储的， 都是字节。



查看文件编码的方式

enca  命令可以查看文件的编码方式



vim 进入命令模式

: set fileencoding 就可以看到文件的编码方式了





字符集：：：



0.Unicode 表示全世界所有的语言文字符号。





1.ASCII

American Standard Code for Info Interchange



用7位表示一个字符，共计128种。 2的7次方

用于表示美国使用字符，大写、小写、标点、空格等等，够用。



2.ISO-8859-1

后来法国、德国的不够用了，出现了ISO-8859-1。是对ASCII的扩展，完全兼容ASCII。

用8位（一个字节）表示一个字符。

2的8次方，共256个字符。



3.中文，ISO-8859-1不够用了



出现GB2312，  GB（中国国标），对所有的汉字进行编码， 每一个汉字都有一个特定编码。

用两个字节，表示一个汉字。



但是依然会有生僻字无法表示



4.因此出现GBK

对GB2312的扩展和延伸。是GB2312的超集，完全兼容GB2312



5.又不够了

GB18030 表示汉字最多了。



6.宝岛台湾

BIG5，与GB2312 没关系



7.全球所有字符集汇总。

Unicode   表示全部所有的字符。最广泛最广的。

采用2个字节表示一个字符。

\uxxxx





8.采用Unicode能够表示所有的字符，但是对于存储的空间，特别大。

刚好翻一倍。

Unicode并不适合存储。



9.因此出现了UTF（Unicode Translation Format）

Unicode 是编码方式，也就是字符集。Unicode 为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF (十六进制)，有 110 多万，每个字符都有一个唯一的 Unicode 编号，这个编号一般写成 16 进制，在前面加上 U+。例如：“马”的 Unicode 是U+9A6C。

Unicode 就相当于一张表，建立了字符与编号之间的联系

UTF 本质是一种存储格式。





UTF-16采用2个字节表示一个字符。

UTF-16LE（little endian）在文件最开始 加入0xFFFE

UTF-16BE（big endian）在文件最开始 加入0xFEFF



UTF-16依然会浪费，因此出现UTF-8（变长字节表示形式）



比如A，a，用一个字节表示。   0-127 的  编码方式与ASCII完全一致。

兼容ASCII 和  ISO-8859-1



比如对于中文，一般都是用三个字节表示一个中文字符。

最多，用6个字节表示一个字符。



字节序

BOM   （Byte Order Mark），EditPlus里可以选  Non BOM  或者 是 With BOM



Windows存储UTF-8格式，默认会带BOM

Mac， Linux 是不带BOM的。

用文件查看器，就能看到16进制的BOM头



Reload会重新加载。

Convert把原来的内容保存并放在新的文件当中









2020-07-29 笔记

1，将字节数组  二进制转成字符串  字符这样的，
2，编码   ，将字符字符串转成字节，字节数组这样的。也就是二进制这样的
3，磁盘上上存储的最终形式都是字节
4，字符，字符串只是存储内容（字节数组）的一种表示形式，就是我们能看懂的一种形式
5，一个字节，8位。1k是1024字节
6，存储在磁盘上的文件都有一个默认的编码的
7，


1，ascii  美国 信息交换标准代码
7位表示一个字符， 共计 128个。
2，ascii 不够用了，比如法国，德国，
出现iso8859-1，8位表示一个字符，完全利用一个字节，不会出现位丢失，共计256，在原有ascii的基础上扩展的，完全兼容ascii
3，中文，日语来了，
出现gn2312  国标，是中国定的标准，√所有汉子进行编码，使得每一个汉子都有一个对应的编码
2个字节表示一个汉子
4，汉子中的生僻字无法表示了
出现gbk，是gb2312的扩展和延伸，把生僻字加入了
5，又不够了，出现gb18030，最完整的汉子的表示形式
6，台湾  big5，繁体中文
7，全世界所有字符集汇总，就成了unicode  最广泛，最全的，2个字节表示一个字符。
\uxxxx   这样的形式
问题出现了，存储容量急剧增加。对于ascii 或者iso8859-1这样的，高位必须全部填入0。因此不适合存储，浪费呢

然后就出现了utf8  unicode  translation format

unicode是编码方式，
utf8是存储方式
utf8去unicode的实现方式之一

utf16是用两个字节存储一个字节，定长。
utf16le  小端
utf16be 大端
如果文件开头出现0xFeff 代表大端
0xffef  代表小端

utf8 变长存储
英文，一个字节表示
比如iso8859-1  或者ascii斗完全相同(兼容的)
对于中文，3个字节表示

字节序bom
windows存储utf8格式的文档，默认会带 bom




unicode是编码方式
utf8是存储方式，因此涉及到二进制的，最好都用utf81，将字节数组  二进制转成字符串  字符这样的，
2，编码   ，将字符字符串转成字节，字节数组这样的。也就是二进制这样的
3，磁盘上上存储的最终形式都是字节
4，字符，字符串只是存储内容（字节数组）的一种表示形式，就是我们能看懂的一种形式
5，一个字节，8位。1k是1024字节
6，存储在磁盘上的文件都有一个默认的编码的
7，


1，ascii  美国 信息交换标准代码
7位表示一个字符， 共计 128个。
2，ascii 不够用了，比如法国，德国，
出现iso8859-1，8位表示一个字符，完全利用一个字节，不会出现位丢失，共计256，在原有ascii的基础上扩展的，完全兼容ascii
3，中文，日语来了，
出现gn2312  国标，是中国定的标准，√所有汉子进行编码，使得每一个汉子都有一个对应的编码
2个字节表示一个汉子
4，汉子中的生僻字无法表示了
出现gbk，是gb2312的扩展和延伸，把生僻字加入了
5，又不够了，出现gb18030，最完整的汉子的表示形式
6，台湾  big5，繁体中文
7，全世界所有字符集汇总，就成了unicode  最广泛，最全的，2个字节表示一个字符。
\uxxxx   这样的形式
问题出现了，存储容量急剧增加。对于ascii 或者iso8859-1这样的，高位必须全部填入0。因此不适合存储，浪费呢

然后就出现了utf8  unicode  translation format

unicode是编码方式，
utf8是存储方式
utf8去unicode的实现方式之一

utf16是用两个字节存储一个字节，定长。
utf16le  小端
utf16be 大端
如果文件开头出现0xFeff 代表大端
0xffef  代表小端

utf8 变长存储
英文，一个字节表示
比如iso8859-1  或者ascii斗完全相同(兼容的)
对于中文，3个字节表示

字节序bom
windows存储utf8格式的文档，默认会带 bom



unicode是编码方式
utf8是针对unicode的存储方式，便于存储和传输， 因此涉及到二进制的存储和传输，最好都用utf8



存储的时候， 我们是要把unicode 的编号存在磁盘上，UTF 说白了，UTF就是如何存储unicode 编号的规则。就是如何把unicode的编号转成二进制的。 就是这么个规则。





Unicode 为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF (十六进制)，有 110 多万，每个字符都有一个唯一的 Unicode 编号，这个编号一般写成 16 进制，在前面加上 U+。例如：“马”的 Unicode 是U+9A6C。

Unicode 就相当于一张表，建立了字符与编号之间的联系


![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/unicode_code.png)



它是一种规定，Unicode 本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。

UTF 就是专门制定  unicode 编号存储的方案， 也就是如何将  unicode 编码转为二进制



**3、UTF-8** 

UTF-8 就是使用变长字节表示,顾名思义，就是使用的字节数可变，这个变化是根据 Unicode 编号的大小有关，编号小的使用的字节就少，编号大的使用的字节就多。使用的字节个数从 1 到 4 个不等。

UTF-8 的编码规则是：

**①** 对于单字节的符号，字节的第一位设为 0，后面的7位为这个符号的 Unicode 码，因此对于英文字母，UTF-8 编码和 ASCII 码是相同的。 

**②** 对于n字节的符号（n>1）,第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10，剩下的没有提及的二进制位，全部为这个符号的 Unicode 码 。

举个例子：比如说一个字符的 Unicode 编码是 130，显然按照 UTF-8 的规则一个字节是表示不了它（因为如果是一个字节的话前面的一位必须是 0），所以需要两个字节(n = 2)。

根据规则，第一个字节的前 2 位都设为 1，第 3(2+1) 位设为 0，则第一个字节为：110X XXXX，后面字节的前两位一律设为 10，后面只剩下一个字节，所以后面的字节为：10XX XXXX。

所以它的格式为 110XXXXX 10XXXXXX 。

下面我们来具体看看具体的 Unicode 编号范围与对应的 UTF-8 二进制格式 

![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/unicode_with_utf8.png)

那么对于一个具体的 Unicode 编号，具体怎么进行 UTF-8 的编码呢？

首先找到该 Unicode 编号所在的编号范围，进而可以找到与之对应的二进制格式，然后将该 Unicode 编号转化为二进制数（去掉高位的 0），最后将该二进制数从右向左依次填入二进制格式的 X 中，如果还有 X 未填，则设为 0 。

比如：“马”的 Unicode 编号是：0x9A6C，整数编号是 39532，对应第三个范围（2048 - 65535），其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532 对应的二进制是 1001 1010 0110 1100，将二进制填入进入就为： 

11101001 10101001 10101100 。

![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/unicode_find_utf8.png)


![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/unicode_find_utf8_2.png)

由于 UTF-8 的处理单元为一个字节（也就是一次处理一个字节），所以处理器在处理的时候就不需要考虑这一个字节的存储是在高位还是在低位，直接拿到这个字节进行处理就行了，因为大小端是针对大于一个字节的数的存储问题而言的。

综上所述，UTF-8、UTF-16、UTF-32 都是 Unicode 的一种实现。





后面的是参考：https://blog.csdn.net/zhusongziye/article/details/84261211

https://www.zhihu.com/question/23374078

这两个说的很清楚









