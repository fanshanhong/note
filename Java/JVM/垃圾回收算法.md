---

title: 垃圾回收算法

date: 2020-03-16

categories: 

   - Kotlin

tags: 

   - Kotlin 

description: 
​
---

<!-- TOC -->

- [标记清除](#标记清除)
- [标记整理 (Mark Compact)](#标记整理-mark-compact)
- [复制](#复制)
- [分代收集算法](#分代收集算法)

<!-- /TOC -->


# 标记清除


两个阶段:

1. 标记

遍历堆上的所有对象, 看这个对象是否被 GC Root 直接/间接引用. 如果没有, 就认为是垃圾, 可回收, 先标记一下.

2. 清除(Mark Sweep)

将标记的垃圾对象占用的空间释放掉.

所谓释放, 并不是把那一块内存上的每个字节清零.  只是把这个对象所占用的内存的起始和结束地址, 记录下来, 放入到一个空闲内存的地址列表中.

下次再分配内存的时候, 就可以到空闲列表中去查找, 看是否有一块足够的空间来容纳新的对象.


优点: 清除操作, 只需要把垃圾对象所占用的内存的起始和结束地址记录下来, 放入空闲的地址列表, 因此速度快.

缺点: 容易产生很多的内存碎片. 即内存不连续.

因为清除后, 并没有整理.

# 标记整理 (Mark Compact)

避免产生内存碎片


1. 标记

同 标记清除  清除算法一样
遍历堆上的所有对象, 看这个对象是否被 GC Root 直接/间接引用. 如果没有, 就认为是垃圾, 可回收, 先标记一下.

2. 整理

在清理的过程中, 把 非垃圾对象 向前移动.

整理之后, 就可以有连续的内存空间了.

让所有存活对象向一端移动, 然后直接清除端边界以外的内存即可. 这就是整理的过程


整理涉及到对象移动, 效率较低. 优点是:避免产生内存碎片.



# 复制

将内存区(其实说的是堆内存区域)划分成大小相等的两块, 一块为 FROM, 一块为 TO

FROM 用于内存分配,  TO 空闲

他垃圾回收也是两步:
1. 标记, 遍历, 找到不被引用的对象, 标记为垃圾对象
2. 复制. 将FROM 区域上存活的对象, 全部复制到TO 区域, 复制的过程, 完成碎片的整理. 然后将FROM的内存全部释放. 最后交换 FROM 和 TO.

优点:避免产生内存碎片
缺点:占用双倍的内存, 或者说可用内存减半.


# 分代收集算法

JVM的垃圾回收机制的实现, 是结合这几种算法, 来共同实现的.