---
title: Android系统启动流程

date: 2018-10-08

categories: 
   - Android

tags: 
   - Android 


description: ​
---

<!-- TOC -->

- [init进程](#init进程)
- [Zygote](#zygote)
    - [启动 SystemServer](#启动-systemserver)
    - [runSelectLoop](#runselectloop)
    - [Zygote总结](#zygote总结)
- [SystemServer](#systemserver)
- [Launcher概述](#launcher概述)
    - [Launcher启动流程](#launcher启动流程)
- [Launcher3应用分析](#launcher3应用分析)

<!-- /TOC -->


# init进程

init进程是Android系统中用户空间的第一个进程，作为第一个进程，它被赋予了很多极其重要的工作职责，比如创建zygote(孵化器)和属性服务等。init进程是由多个源文件共同组成的，这些文件位于源码目录system/core/init


Android系统启动流程的前几步：
1. Android设备上电后，首先会从预定义的地方（固化在处理器片上ROM）开始执行，片上ROM会寻找Bootloader代码，并加载到内存执行。
2. 当Bootloader完成基本的处理器和平台初始化之后，它的主要任务是获取并引导一个完整的操作系统。
3. Linux内核开始启动，初始化各种软硬件环境，加载驱动程序，挂载根文件系统，并执行init程序，由此开启Android的世界。


因此，init程序是分析Android启动过程中最核心的程序。


init程序最核心的工作主要有3点：

（1） 创建和挂载一些系统目录/设备节点，设置权限，如：/dev, /proc, and /sys

（2） 初始化属性资源，并启动属性服务

（3） 解析 init.rc， 在init子进程中启动 zygote

init.rc是一个配置文件，内部由Android初始化语言编写（Android Init Language）编写的脚本

在 init.rc中，里面配置了要启动的各种服务， 其中定了 创建 zygote 进程的相关信息，包括进程名称，路径。

```
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks
```

其中service用于通知init进程创建名zygote的进程，这个zygote进程执行程序的路径为/system/bin/app_process64，后面的则是要传给app_process64的参数。class main指的是zygote的class name为main，后文会用到它。



解析完了， 就去启动 zygote 进程，


zygote 进程的创建：

1. 在 init 进程中 fork 子进程， 在子进程中通过 execve 启动zygote程序。
其实，zygote进程就是init的子进程了。

执行execve 就执行下面的main方法了





# Zygote

在Android系统中，DVM(Dalvik虚拟机)、应用程序进程以及运行系统的关键服务的SystemServer进程都是由Zygote进程来创建的，我们也将它称为孵化器。它通过fock(复制进程)的形式来创建应用程序进程和SystemServer进程，由于Zygote进程在启动时会创建DVM，因此通过fock而创建的应用程序进程和SystemServer进程可以在内部获取一个DVM的实例拷贝。


```cpp
int main(int argc, char* const argv[])
{
...

    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));
   ...
     Vector<String8> args;
    if (!className.isEmpty()) {
        args.add(application ? String8("application") : String8("tool"));
        runtime.setClassNameAndArgs(className, argc - i, argv + i);
    } else {
        // We're in zygote mode.
        maybeCreateDalvikCache();
        if (startSystemServer) {
            args.add(String8("start-system-server"));//1
        }
        char prop[PROP_VALUE_MAX];
        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) {
            LOG_ALWAYS_FATAL("app_process: Unable to determine ABI list from property %s.",
                ABI_LIST_PROPERTY);
            return 11;
        }
        String8 abiFlag("--abi-list=");
        abiFlag.append(prop);
        args.add(abiFlag);
        for (; i < argc; ++i) {
            args.add(String8(argv[i]));
        }
    }
    if (!niceName.isEmpty()) {
        runtime.setArgv0(niceName.string());
        set_process_name(niceName.string());
    }
    if (zygote) {
        runtime.start("com.android.internal.os.ZygoteInit", args, zygote);//2
    } else if (className) {
        runtime.start("com.android.internal.os.RuntimeInit", args, zygote);
    } else {
        fprintf(stderr, "Error: no class name or --zygote supplied.\n");
        app_usage();
        LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
        return 10;
    }
}
```

注释1处如果startSystemServer为true的话(默认为true)，将”start-system-server”放入启动的参数args。
注释2处调用注释2处这里调用runtime的start函数来启动zygote进程，并将args传入，这样启动zygote进程后，zygote进程会将SystemServer进程启动。 

注意， 这个main方法是在init的 fork的子进程中执行的， 我们称它为： zygote进程。

start 方法

```java
void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
{
    ...
    /* start the virtual machine */
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    if (startVm(&mJavaVM, &env, zygote) != 0) {//1
        return;
    }
    onVmCreated(env);
    if (startReg(env) < 0) {//2
        ALOGE("Unable to register all android natives\n");
        return;
    }
    jclass stringClass;
    jobjectArray strArray;
    jstring classNameStr;

    stringClass = env->FindClass("java/lang/String");
    assert(stringClass != NULL);
    //创建数组
    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);
    assert(strArray != NULL);
    //从app_main的main函数得知className为com.android.internal.os.ZygoteInit
    classNameStr = env->NewStringUTF(className);
    assert(classNameStr != NULL);
    env->SetObjectArrayElement(strArray, 0, classNameStr);

    for (size_t i = 0; i < options.size(); ++i) {
        jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());
        assert(optionsStr != NULL);
        env->SetObjectArrayElement(strArray, i + 1, optionsStr);
    }
    char* slashClassName = toSlashClassName(className);
    jclass startClass = env->FindClass(slashClassName);
    if (startClass == NULL) {
        ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
        /* keep going */
    } else {
    //找到ZygoteInit的main函数
        jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
            "([Ljava/lang/String;)V");//3
        if (startMeth == NULL) {
            ALOGE("JavaVM unable to find main() in '%s'\n", className);
            /* keep going */
        } else {
        //通过JNI调用ZygoteInit的main函数
            env->CallStaticVoidMethod(startClass, startMeth, strArray);//4

#if 0
            if (env->ExceptionCheck())
                threadExitUncaughtException(env);
#endif
        }
    }
  ...
}
````

注释1处调用startVm函数来创建JavaVm(DVM)，注释2处调用startReg函数用来为DVM注册JNI。注释3处的代码用来找到ZygoteInit的main函数，其中startClass从app_main的main函数得知为com.android.internal.os.ZygoteInit。注释4处通过JNI调用ZygoteInit的main函数，因为ZygoteInit的main函数是Java编写的，因此需要通过JNI调用。

主要就是：创建 Davlik 虚拟机。然后通过JNI调用Java层 com.android.internal.os.ZygoteInit 的 main方法



在 ZygoteInit 的 main中：
```
public static void main(String argv[]) {
       ...
        try {
         ...       
            //注册Zygote用的Socket
            registerZygoteSocket(socketName);//1
           ...
           //预加载类和资源
           preload();//2
           ...
            if (startSystemServer) {
            //启动SystemServer进程
                startSystemServer(abiList, socketName);//3
            }
            Log.i(TAG, "Accepting command socket connections");
            //等待客户端请求
            runSelectLoop(abiList);//4
            closeServerSocket();
        } catch (MethodAndArgsCaller caller) {
            caller.run();
        } catch (RuntimeException ex) {
            Log.e(TAG, "Zygote died with exception", ex);
            closeServerSocket();
            throw ex;
        }
    }
```

1. 创建LocalServerSocket，也就是服务端的Socket。当Zygote进程将SystemServer进程启动后，就会在这个服务端的Socket上来等待ActivityManagerService请求Zygote进程来创建新的应用程序进程。
2. 预加载资源
3. 启动SystemServer进程。这样系统的关键服务也会由SystemServer进程启动起来。
4. 4处调用runSelectLoop函数来等待客户端请求



## 启动 SystemServer


```java

 private static boolean startSystemServer(String abiList, String socketName)
            throws MethodAndArgsCaller, RuntimeException {
...
        /* Hardcoded command line to start the system server */
         /*1*/
        String args[] = {
            "--setuid=1000",
            "--setgid=1000",
            "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010",
            "--capabilities=" + capabilities + "," + capabilities,
            "--nice-name=system_server",
            "--runtime-args",
            "com.android.server.SystemServer",
        };
        ZygoteConnection.Arguments parsedArgs = null;

        int pid;

        try {
            parsedArgs = new ZygoteConnection.Arguments(args);//2
            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);

            /*3*/
            pid = Zygote.forkSystemServer(
                    parsedArgs.uid, parsedArgs.gid,
                    parsedArgs.gids,
                    parsedArgs.debugFlags,
                    null,
                    parsedArgs.permittedCapabilities,
                    parsedArgs.effectiveCapabilities);
        } catch (IllegalArgumentException ex) {
            throw new RuntimeException(ex);
        }
        if (pid == 0) {
            if (hasSecondZygote(abiList)) {
                waitForSecondaryZygote(socketName);
            }

            handleSystemServerProcess(parsedArgs);//4
        }

        return true;
    }
```

进程名为system_server；启动的类名为com.android.server.SystemServer

注释3处调用Zygote的forkSystemServer，主要通过fork函数在当前进程创建一个子进程，如果返回的pid 为0，也就是表示在新创建的子进程中执行的，则执行注释4处的handleSystemServerProcess来启动SystemServer进程。
因此，SystemServer进程（准确的进程名字为：system_server）， 它是Zygote的子进程。


## runSelectLoop

无限循环用来等待ActivityManagerService请求Zygote进程创建新的应用程序进程。


```java
private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {
        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();
        fds.add(sServerSocket.getFileDescriptor());//1
        peers.add(null);

        while (true) {
            StructPollfd[] pollFds = new StructPollfd[fds.size()];
            for (int i = 0; i < pollFds.length; ++i) {//2
                pollFds[i] = new StructPollfd();
                pollFds[i].fd = fds.get(i);
                pollFds[i].events = (short) POLLIN;
            }
            try {
                Os.poll(pollFds, -1);
            } catch (ErrnoException ex) {
                throw new RuntimeException("poll failed", ex);
            }
            for (int i = pollFds.length - 1; i >= 0; --i) {//3
                if ((pollFds[i].revents & POLLIN) == 0) {
                    continue;
                }
                if (i == 0) {
                    ZygoteConnection newPeer = acceptCommandPeer(abiList);//4
                    peers.add(newPeer);
                    fds.add(newPeer.getFileDesciptor());
                } else {
                    boolean done = peers.get(i).runOnce();//5
                    if (done) {
                        peers.remove(i);
                        fds.remove(i);
                    }
                }
            }
        }
    }
```

注释1处中的sServerSocket就是我们在registerZygoteSocket函数中创建的服务端Socket，调用sServerSocket.getFileDescriptor()用来获得该Socket的fd字段的值并添加到fd列表fds中。接下来无限循环用来等待ActivityManagerService请求Zygote进程创建新的应用程序进程。注释2处通过遍历将fds存储的信息转移到pollFds数组中。最后在注释3处对pollFds进行遍历，如果i==0则说明服务端Socket与客户端连接上，也就是当前Zygote进程与ActivityManagerService建立连接成功。则在注释4处通过acceptCommandPeer函数得到ZygoteConnection类并添加到Socket连接列表peers中，接着将该ZygoteConnection的fd添加到fd列表fds中，以便可以接收到ActivityManagerService发送过来的请求。如果i的值大于0，则说明ActivityManagerService向Zygote进程发送了一个创建应用进程的请求，则在注释5处调用ZygoteConnection的runOnce函数来创建一个新的应用程序进程。并在成功创建后将这个连接从Socket连接列表peers和fd列表fds中清除。




## Zygote总结
Zygote启动流程就讲到这，Zygote进程共做了如下几件事：
1.创建AppRuntime并调用其start方法，启动Zygote进程。
2.创建DVM并为DVM注册JNI.
3.通过JNI调用ZygoteInit的main函数进入Zygote的Java框架层。
4.通过registerZygoteSocket函数创建服务端Socket，并通过runSelectLoop函数等待ActivityManagerService的请求来创建新的应用程序进程。
5.启动SystemServer进程。





# SystemServer

上面说 调用Zygote的forkSystemServer，主要通过fork函数在当前进程创建一个子进程，在Zygote子进程中执行 handleSystemServerProcess(parsedArgs);来启动SyetemServer进程。

因此，我们说： SyetemServer进程是Zygote的子进程



handleSystemServerProcess(parsedArgs); 

1. 通过调用native 代码（C++），在SyetemServer启动一个Binder线程池，这样SyetemServer进程就可以使用Binder来与其他进程进行通信了

2. 反射调用 SystemServer的main函数

frameworks/base/services/java/com/android/server/SystemServer.java
```java
 public static void main(String[] args) {
        new SystemServer().run();
    }


    private void run() {
        ...
            System.loadLibrary("android_servers");//1
        ...
            mSystemServiceManager = new SystemServiceManager(mSystemContext);//2
            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
        ...    
         try {
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartServices");
            startBootstrapServices();//3
            startCoreServices();//4
            startOtherServices();//5
        } catch (Throwable ex) {
            Slog.e("System", "******************************************");
            Slog.e("System", "************ Failure starting system services", ex);
            throw ex;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        ...
    }
```
run函数代码很多，关键就是在注释1处加载了libandroid_servers.so。接下来在注释2处创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理。启动系统的各种服务，在注释3中的startBootstrapServices函数中用SystemServiceManager启动了ActivityManagerService、PowerManagerService、PackageManagerService等服务。在注释4处的函数中则启动了BatteryService、UsageStatsService和WebViewUpdateService。注释5处的startOtherServices函数中则启动了CameraService、AlarmManagerService、VrManagerService等服务，这些服务的父类为SystemService。从注释3、4、5的函数可以看出，官方把系统服务分为了三种类型，分别是引导服务、核心服务和其他服务，其中其他服务为一些非紧要和一些不需要立即启动的服务。系统服务大约有80多个，这里列出部分系统服务以及它们的作用如下表所示：



|  引导服务	 | 作 用  
---------------------
| Installer	      | 系统安装apk时的一个服务类，启动完成Installer服务之后才能启动其他的系统服务
| ActivityManagerService	| 负责四大组件的启动、切换、调度。
| PowerManagerService	| 计算系统中和Power相关的计算，然后决策系统应该如何反应
| | LightsService	| 管理和显示背光LED
| DisplayManagerService	| 用来管理所有显示设备
| UserManagerService	| 多用户模式管理
| SensorService	| 为系统提供各种感应器服务
| PackageManagerService	| 用来对apk进行安装、解析、删除、卸载等等操作
| 核心服务	
| BatteryService	| 管理电池相关的服务
| UsageStatsService	| 收集用户使用每一个APP的频率、使用时常
| WebViewUpdateService	| WebView更新服务
| 其他服务	
| CameraService	| 摄像头相关服务
| AlarmManagerService	| 全局定时器管理服务
| InputManagerService	| 管理输入事件
| WindowManagerService	| 窗口管理服务
| VrManagerService	| VR模式管理服务
| BluetoothService	| 蓝牙管理服务
| NotificationManagerService	| 通知管理服务
| DeviceStorageMonitorService	| 存储相关管理服务
| LocationManagerService	| 定位管理服务
| AudioService	| 音频相关管理服务

比如要启动PowerManagerService则会调用如下代码：

mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);
startService函数如下所示。

frameworks/base/services/core/java/com/android/server/SystemServiceManager.java

  public <T extends SystemService> T startService(Class<T> serviceClass) {
  ...
            final T service;
            try {
                Constructor<T> constructor = serviceClass.getConstructor(Context.class);
                service = constructor.newInstance(mContext);//1
            } catch (InstantiationException ex) {
                throw new RuntimeException("Failed to create service " + name
                        + ": service could not be instantiated", ex);
            }
...
            // Register it.
            mServices.add(service);//2
            // Start it.
            try {
                service.onStart();
            } catch (RuntimeException ex) {
                throw new RuntimeException("Failed to start service " + name
                        + ": onStart threw an exception", ex);
            }
            return service;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
    }




注释1处的代码用来创建SystemService，这里的SystemService是PowerManagerService，在注释2处将PowerManagerService添加到mServices中，这里mServices是一个存储SystemService类型的ArrayList。接着调用PowerManagerService的onStart函数启动PowerManagerService并返回，这样就完成了PowerManagerService启动的过程。
除了用mSystemServiceManager的startService函数来启动系统服务外，也可以通过如下形式来启动系统服务，以PackageManagerService为例：

 mPackageManagerService = PackageManagerService.main(mSystemContext, installer,
                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);


直接调用了PackageManagerService的main函数：
frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java

public static PackageManagerService main(Context context, Installer installer,
        boolean factoryTest, boolean onlyCore) {
    // Self-check for initial settings.
    PackageManagerServiceCompilerMapping.checkProperties();
    PackageManagerService m = new PackageManagerService(context, installer,
            factoryTest, onlyCore);//1
    m.enableSystemUserPackages();
    // Disable any carrier apps. We do this very early in boot to prevent the apps from being
    // disabled after already being started.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(context.getOpPackageName(), m,
            UserHandle.USER_SYSTEM);
    ServiceManager.addService("package", m);//2
    return m;
}

注释1处直接创建PackageManagerService并在注释2处将PackageManagerService注册到ServiceManager中，ServiceManager用来管理系统中的各种Service，用于系统C/S架构中的Binder机制通信：Client端要使用某个Service，则需要先到ServiceManager查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通讯通路，这样Client端就可以使用Service了。还有的服务是直接注册到ServiceManager中的，如下所示。

frameworks/base/services/java/com/android/server/SystemServer.java

  telephonyRegistry = new TelephonyRegistry(context);
  ServiceManager.addService("telephony.registry", telephonyRegistry);
4.总结SyetemServer进程
SyetemServer在启动时做了如下工作：
1.启动Binder线程池，这样就可以与其他进程进行通信。
2.创建SystemServiceManager用于对系统的服务进行创建、启动和生命周期管理。
3.启动各种系统服务。




注意： init进程会进入无限死循环，这样，init进程就不会结束。


init进程(pid=1)是Linux系统中用户空间的第一个进程，主要工作如下：

* 创建一块共享的内存空间，用于属性服务器;
* 解析各个rc文件，并启动相应属性服务进程;
* 初始化epoll，依次设置signal、property、keychord这3个fd可读时相对应的回调函数;
* 进入无限循环状态，执行如下流程：
   * 检查action_queue列表是否为空，若不为空则执行相应的action;
   * 检查是否需要重启的进程，若有则将其重新启动;
   * 进入epoll_wait等待状态，直到系统属性变化事件(property_set改变属性值)，或者收到子进程的信号SIGCHLD，再或者keychord 键盘输入事件，则会退出等待状态，执行相应的回调函数。

可见init进程在开机之后的核心工作就是响应property变化事件和回收僵尸进程。

1. 当某个进程调用property_set来改变一个系统属性值时，系统会通过socket向init进程发送一个property变化的事件通知，那么property fd会变成可读，init进程采用epoll机制监听该fd则会 触发回调handle_property_set_fd()方法。

2. 回收僵尸进程，在Linux内核中，如父进程不等待子进程的结束直接退出，会导致子进程在结束后变成僵尸进程，占用系统资源。为此，init进程专门安装了SIGCHLD信号接收器，当某些子进程退出时发现其父进程已经退出，则会向init进程发送SIGCHLD信号，init进程调用回调方法handle_signal()来回收僵尸子进程。





# Launcher概述
Android系统启动的最后一步是启动一个Home应用程序，这个应用程序用来显示系统中已经安装的应用程序，这个Home应用程序就叫做Launcher。应用程序Launcher在启动过程中会请求PackageManagerService返回系统中已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些快捷图标来启动相应的应用程序。

## Launcher启动流程

SyetemServer进程在启动的过程中会启动PackageManagerService，PackageManagerService启动后会将系统中的应用程序安装完成。在此前已经启动的ActivityManagerService会将Launcher启动起来。


frameworks/base/services/java/com/android/server/SystemServer.java
```java
 public static void main(String[] args) {
        new SystemServer().run();
    }


    private void run() {
        ...
            System.loadLibrary("android_servers");//1
        ...
            mSystemServiceManager = new SystemServiceManager(mSystemContext);//2
            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
        ...    
         try {
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartServices");
            startBootstrapServices();//3
            startCoreServices();//4
            startOtherServices();//5
        } catch (Throwable ex) {
            Slog.e("System", "******************************************");
            Slog.e("System", "************ Failure starting system services", ex);
            throw ex;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        ...
    }
```

ActivityManagerService 和 PackageManagerService 都算是引导服务。因此是在 startBootstrapServices() 中启动。

启动Launcher 是在 startOtherServices()中启动，这个时候ActivityManagerService已经启动好了。

启动Launcher的入口为ActivityManagerService的systemReady函数，如下所示

```java
   private void startOtherServices() {
   ...
   mActivityManagerService.systemReady(new Runnable() {
               @Override
               public void run() {
                  Slog.i(TAG, "Making services ready");
                  mSystemServiceManager.startBootPhase(
                           SystemService.PHASE_ACTIVITY_MANAGER_READY);

   ...
   }
   ...
   }
```




```java
Intent getHomeIntent() {
    Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        intent.addCategory(Intent.CATEGORY_HOME);
    }
    return intent;
}
```
通过getHomeIntent 来构建一个category为CATEGORY_HOME的Intent，表明是Home Activity

Launcher的Manifest文件中的intent-filter标签匹配了Action为Intent.ACTION_MAIN，Category为Intent.CATEGORY_HOME
packages/apps/Launcher3/AndroidManifest.xml

```xml
<manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.android.launcher3">
    <uses-sdk android:targetSdkVersion="23" android:minSdkVersion="16"/>
 ...
 <application
        ...
        <activity
            android:name="com.android.launcher3.Launcher"
            android:launchMode="singleTask"
            android:clearTaskOnLaunch="true"
            android:stateNotNeeded="true"
            android:theme="@style/Theme"
            android:windowSoftInputMode="adjustPan"
            android:screenOrientation="nosensor"
            android:configChanges="keyboard|keyboardHidden|navigation"
            android:resumeWhilePausing="true"
            android:taskAffinity=""
            android:enabled="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.HOME" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.MONKEY"/>
            </intent-filter>
        </activity>
...
  </application> 
</manifest>       
```

构建好 HomeIntent 之后， 通过Binder跨进程通知PackageManagerService从系统所安装的应用中，找到符合HomeIntent的Activity。

找到后， 通过 startActivity启动它。

最终调用到 ActivityManagerService 的startProcess()。

然后ActivityManagerService会通过Socket，与Zygote进程进行通信。ActivityManagerService向Zygote进程发送了一个创建应用进程的请求，其中processClass ="android.app.ActivityThread"，然后 Zygote进程会fork一个新的进程（其实就是Launcher应用的进程），在新的进程中（Launcher进程），通过反射，执行"android.app.ActivityThread"的main方法。


接下来的Launcher启动任务交给了ActivityThread来进行
在 ActivityThread  的main方法中，Activity的onCreate()被调用，Launcher的启动完成，Launcher被真正创建起来。


应用程序Launcher就会被启动起来，并执行它的onCreate函数。







# Launcher3应用分析




![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/android_launcher.png)




在 Launcher的onCreate中，会加载并显示应用程序图标。看看所有桌面apk的信息是怎么获取，调用getActivityList获取的，其中第一个参数packageName传入的是null，查询所有配置了intent Action为ACTION_MAIN，Category为CATEGORY_LAUNCHER的应用集合列表
```java
public List<LauncherActivityInfoCompat> getActivityList(String packageName,
            UserHandleCompat user) {
        final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
        mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        mainIntent.setPackage(packageName);
        List<ResolveInfo> infos = mPm.queryIntentActivities(mainIntent, 0);
        List<LauncherActivityInfoCompat> list =
                new ArrayList<LauncherActivityInfoCompat>(infos.size());
        for (ResolveInfo info : infos) {
            list.add(new LauncherActivityInfoCompatV16(mContext, info));
        }
        return list;
    }
   ```


Launcher是用工作区Workspace的形式来显示系统安装的应用程序的快捷图标，每一个工作区都是来描述一个抽象桌面的，它由n个屏幕组成，每个屏幕又分n个单元格，每个单元格用来显示一个应用程序的快捷图标。