---
title: Binder系统核心

date: 2021-03-08

categories: 
   - Android

tags: 
   - Android 


description: ​
---

<!-- TOC -->

- [Binder系统核心](#binder系统核心)
    - [IPC 和 RPC](#ipc-和-rpc)
    - [数据传输过程](#数据传输过程)
- [ServiceManager流程详解](#servicemanager流程详解)
- [Binder流程](#binder流程)
- [Binder addService流程图](#binder-addservice流程图)
- [Binder getService 流程图](#binder-getservice-流程图)
- [addService Framework实现](#addservice-framework实现)
- [getService Framework实现](#getservice-framework实现)
- [Android framework 调用服务](#android-framework-调用服务)
- [总结](#总结)

<!-- /TOC -->

# Binder系统核心


先梳理Binder底层，底层的原理清楚了，再来看上层的C++和Java封装。上层的C++和Java，只是基于底层Binder实现，做成了面向对象的方式，更方便使用。


## IPC 和 RPC


IPC（Inter-Process Communication，进程间通信）


进程A 发数据 给进程B，即成为 IPC， 这个概念泛指进程之间任何形式的通信行为



RPC(Remote Process Call)

进程A 想要调用进程B的 hello 方法。
那么进程A需要封装（构造）数据，将数据通过IPC发送给B进程，B进程收到后，取出数据，然后调用自己本地的 hello 方法。


这个过程中，好像A进程直接调用了B进程的 hello 方法一样，这个理解为RPC。



数据传输三大要素

1. 源

进程A

2. 目的
进程B

那么，进程A怎么能知道进程B呢。

用到 ServiceManager

进程B向ServiceManager注册，
然后进程A从ServiceManager查询，拿到进程B的handler。然后可以通过handler去调用进程B的hello方法


3. 数据





![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/binder_arch.png)



Android的通信是基于Client-Server架构的，进程间的通信无非就是Client向Server发起请求，Server响应Client的请求。这里以发起请求为例：当Client向Server发起请求(例如，MediaPlayer向MediaPlayerService发起请求)，Client会先将请求数据从用户空间拷贝到内核空间(将数据从MediaPlayer发给Binder驱动)；数据被拷贝到内核空间之后，再通过驱动程序，将内核空间中的数据拷贝到Server位于用户空间的缓存中(Binder驱动将数据发给MediaPlayerService)。这样，就成功的将Client进程中的请求数据传递到了Server进程中。


在Binder驱动中，将句柄0指定为ServiceManager对应的句柄，通过这个特殊的句柄就能获取ServiceManager对象。


/Volumes/Android/android-source/android-4.0.4_r1/frameworks/base/cmds/servicemanager/service_manager.c


```c
int main(int argc, char **argv)
{
    struct binder_state *bs;
    void *svcmgr = BINDER_SERVICE_MANAGER;

    // 打开驱动程序，内部会调用 bs->fd = open("/dev/binder", O_RDWR);
    bs = binder_open(128*1024);

    // 告知驱动程序，自己就是 servicemanager
    if (binder_become_context_manager(bs)) {
        LOGE("cannot become context manager (%s)\n", strerror(errno));
        return -1;
    }

    svcmgr_handle = svcmgr;

    // 开始循环，死循环，不断从驱动中读取数据，解析数据，处理数据，并发送回复信息
    binder_loop(bs, svcmgr_handler);
    return 0;
}
```


/Volumes/Android/android-source/android-4.0.4_r1/frameworks/base/cmds/servicemanager/bctest.c





## 数据传输过程


binder_proc是描述进程上下文信息的，每一个用户空间的进程都对应一个binder_proc结构体。
binder_node是Binder实体对应的结构体，它是Service在Binder驱动中的体现。
binder_ref是Binder引用对应的结构体，它是Client在Binder驱动中的体现。


handle 是服务的引用。同一个服务，在不同的进程中handle不一致。它是按注册顺序来的。

handle 是进程A 对进程 B提供的服务X 的引用。
进程B可能提供多个服务，X，Y，Z
如果按照XYZ的顺序向进程servicemanager注册，那在servicemanager中， XYZ的handle分别是123
注册之后，
如果 A 去获取服务，按照顺序ZYX， 那对应ZYX的handle 分别是123。

按顺序来的



驱动中，用binder_node 来描述服务。
用 binder_ref 来描述  这个服务的引用（也就是用户态的handle）。
binder_ref 中有个成员  desc， 就等于这个handle值。


当向进程B的X服务发送数据，想要通过这个handle来找到进程B的X服务。
通过handle，在内核中就可以找到binder_ref，通过binder_ref，就能找到对应的服务：binder_node。

然后在binder_node中有个binder_proc ，表示这个服务从属于哪个进程的，这样就找到进程B。
这样，就可以把数据放入进程B的一个链表中，就行了。

注意，这里都是在内核态，是可以把数据放在其他进程的。








注册服务的时候

binder驱动在内核为每个服务创建 binder_node

binder_node 中有 proc=server进程

在Binder驱动转发该请求之前，它其实还做了两件很重要的事：
(01) 当它知道该请求是由一个Serivce发送的时候，它会新建该Serivce对应的Binder实体（binder_node）。
(02) 它在ServiceManager的"保存Binder引用的红黑树"中查找是否存在该Service的Binder引用；找不到的话，就新建该Service对应的Binder引用，并将其添加到"ServiceManager的保存Binder引用的红黑树"中。简言之，Binder驱动会创建Serivce对应的Binder实体，并在ServiceManager的红黑树中添加该Binder实体的Binder引用。


然后binder驱动 会在内核中为servicemanager创建  binder_ref 指向 binder_node
binder_ref.desc = handle  1  2  3 

servicemanager在用户态会保存服务的链表，里面包含 服务名字  和 handle（就是  binder_ref.desc ）


client 向  servicemanager 查询服务

传入 服务名字

servicemanager 用户态就会从链表中根据服务名字查找出handle并交给内核态（binder驱动）

binder驱动从 binder_ref 的红黑树中，根据 handle = binder_ref.desc 找到一个 binder_ref。然后再通过 binder_ref 找到 binder_node。

同时，给client 创建新的binder_ref，指向服务的 binder_node， 这个ref的desc也是从1开始。

然后把数据放在client的todo链表，唤醒client


对于servicemanager，在内核态，有一系列的 binder_ref（就是所有注册过的服务）
对于client，在内核态，也有一系列的binder_ref（就是所有client获取过的服务）

这时，client在内核态其实已经能够通过binder_ref找到想要的服务对应的 binder_node 节点了。
然后，client驱动返回desc给用户态，它就是handle

当client 想要发数据给这个handle，调用服务的方法的时候
驱动中根据handle，找到binder_ref，再找到binder_node，再找到server进程，然后把数据放在server进程的TODO列表。




数据复制



copy_from_user

copy_to_user


mmap， 只需要一次复制





# ServiceManager流程详解

```c
int main(int argc, char **argv)
{
    struct binder_state *bs;
    // 打开驱动程序，内部会调用 bs->fd = open("/dev/binder", O_RDWR);
    bs = binder_open(128*1024);
    if (!bs) {
        ALOGE("failed to open binder driver\n");
        return -1;
    }
    // 告知驱动程序，自己就是 servicemanager
    if (binder_become_context_manager(bs)) {
        ALOGE("cannot become context manager (%s)\n", strerror(errno));
        return -1;
    }

   ...

    // BINDER_SERVICE_MANAGER handler=0，表示的就是servicemanager
    svcmgr_handle = BINDER_SERVICE_MANAGER;
    // 开始循环，死循环，不断从驱动中读取数据，解析数据，处理数据，并发送回复信息
    binder_loop(bs, svcmgr_handler);

    return 0;
}

```

# Binder流程


C++层

"本地服务"就是Service提供的服务本身，而"远程服务"就是服务的代理；"服务接口"则是抽象出了它们的通用接口。这3个角色都是通用的，对于不同的服务而言，它们的名称都不相同。


(01) 当Serivce启动之后，它会先将自己注册到ServiceManager中。注册时，Binder驱动会创建Serivce对应的Binder实体（binder_node），并将"Serivce对应的本地服务对象的地址（就是处理函数的指针）"保存到Binder实体中。注册成功之后，Serivce就进入消息循环（binder_loop），等待Client的请求。
(02) 当Client需要和Serivce通信时，会先获取到Serivce接入点，即获取到远程服务对象（从ServiceManager处获取）；而且Client要获取的远程服务对象是"服务接口"类型的（就是IXXService这样的）。Client向ServiceManager发送获取服务的请求时，会通过IPCThreadState和Binder驱动进行通信；当ServiceManager反馈之后，IPCThreadState会将ServiceManager反馈的"Serivce的Binder引用信息"保存BpBinder中(具体来说，BpBinder的mHandle成员保存的就是Serivce的Binder引用信息)。然后，会根据该BpBinder对象创建对应的远程服务。这样，Client就获取到了远程服务对象，而且远程服务对象的成员中保存了Serivce的Binder引用信息。
(03) 当Client获取到远程服务对象之后，它就可以轻松的和Serivce进行通信了。当它需要向Serivce发送请求时，它会调用远程服务接口；远程服务能够获取到BpBinder对象，而BpBinder则通过IPCThreadState和Binder驱动进行通信。由于BpBinder中保存了Serivce在Binder驱动中的Binder引用；因此，IPCThreadState和Binder驱动通信时，是知道该请求是需要传给哪个Serivce的。Binder驱动通过Binder引用找到对应的Binder实体，然后将Binder实体中保存的"Serivce对应的本地服务对象的地址"返回给用户空间。当IPC收到Binder驱动反馈的内容之后，它从内容中找到"Serivce对应的本地服务对象"，然后调用该对象的onTransact()。不同的本地服务都可以实现自己的onTransact()；这样，不同的服务就可以按照自己的需求来处理请求。



(4) 在初始化完待处理事务t之后，接着将MediaPlayerService请求的数据拷贝到内核空间并解析出来。从数据中解析出MediaPlayerService请求数据中的flat_binder_object对象，只有一个flat_binder_object对象。该flat_binder_object对象的类型是BINDER_TYPE_BINDER，然后调用binder_get_node()在当前进程的上下文环境proc中查找fp->binder对应的Binder实体，fp->binder是Android的flatten_binder()中赋值的，它是MediaPlayerService对象的本地引用的描述(即MediaPlayerService对应的BBinder对象的描述)；此外，在MediaPlayerService是初次与Binder驱动通信，因此肯定找不到该对象fp->binder对应的Binder实体；因此node=NULL。 接下来，就调用binder_new_node()新建fp->binder对应的Binder实体，这也就是MediaPlayerService对应的Binder实体。然后，调用binder_get_ref_for_node(target_proc, node)获取该Binder实体在target_proc(即ServiceManager的进程上下文环境)中的Binder引用，此时，在target_proc中肯定也找不到该Binder实体对应的引用；那么，就新建Binder实体的引用，并将其添加到target_proc->refs_by_node红黑树 和 target_proc->refs_by_desc红黑树中。 这样，Service Manager的进程上下文中就存在MediaPlayerService的Binder引用，Service Manager也就可以对MediaPlayerService进行管理了！然后，修改fp->type=BINDER_TYPE_HANDLE，并使fp->handle = ref->desc。这样，就将MediaPlayerService的请求数据解析出来，并且在Binder驱动中创建了MediaPlayerService对应的Binder实体，而且将该Binder实体添加到MediaPlayerService的进程上下文proc中。更重要的是，在ServiceManager的refs_by_node和refs_by_desc这两颗红黑树中创建了"MediaPlayerService对应的Binder实体的Binder引用"。这意味着，在Binder驱动中，已经能在ServiceManager的进程上下文中找到MediaPlayerService，其中该流程涉及的主要源码如下：



![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/binder_arch2.png)

前面说过，Server是以服务的形式注册到ServiceManager中，而Server在Client中则是以远程服务的形式存在的。因此，这个图的主干就是理清楚本地服务和远程服务这两者之间的关系。
"本地服务"就是Server提供的服务本身，而"远程服务"就是服务的代理；"服务接口"则是抽象出了它们的通用接口。这3个角色都是通用的，对于不同的服务而言，它们的名称都不相同。例如，对于MediaPlayerService服务而言，本地服务就是MediaPlayerService自身，远程服务是BpMediaPlayerService，而服务接口是IMediaPlayerService。当Client需要向MediaPlayerService发送请求时，它需要先获取到服务的代理(即，远程服务对象)，也就是BpMediaPlayerService实例，然后通过该实例和MediaPlayerService进行通信。



(01) 当Server启动之后，它会先将自己注册到ServiceManager中。注册时，Binder驱动会创建Server对应的Binder实体，并将"Server对应的本地服务对象的地址"保存到Binder实体中。注册成功之后，Server就进入消息循环，等待Client的请求。
(02) 当Client需要和Server通信时，会先获取到Server接入点，即获取到远程服务对象；而且Client要获取的远程服务对象是"服务接口"类型的。Client向ServiceManager发送获取服务的请求时，会通过IPCThreadState和Binder驱动进行通信；当ServiceManager反馈之后，IPCThreadState会将ServiceManager反馈的"Server的Binder引用信息"保存BpBinder中(具体来说，BpBinder的mHandle成员保存的就是Server的Binder引用信息)。然后，会根据该BpBinder对象创建对应的远程服务。这样，Client就获取到了远程服务对象，而且远程服务对象的成员中保存了Server的Binder引用信息。
(03) 当Client获取到远程服务对象之后，它就可以轻松的和Server进行通信了。当它需要向Server发送请求时，它会调用远程服务接口；远程服务能够获取到BpBinder对象，而BpBinder则通过IPCThreadState和Binder驱动进行通信。由于BpBinder中保存了Server在Binder驱动中的Binder引用；因此，IPCThreadState和Binder驱动通信时，是知道该请求是需要传给哪个Server的。Binder驱动通过Binder引用找到对应的Binder实体，然后将Binder实体中保存的"Server对应的本地服务对象的地址"返回给用户空间。当IPC收到Binder驱动反馈的内容之后，它从内容中找到"Server对应的本地服务对象"，然后调用该对象的onTransact()。不同的本地服务都可以实现自己的onTransact()；这样，不同的服务就可以按照自己的需求来处理请求。



# Binder addService流程图



![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/addService.png)



# Binder getService 流程图



![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/getService_.png)




# addService Framework实现

![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/java_add_service.png)



# getService Framework实现

![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/java_get_service.png)


# Android framework 调用服务
![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/java_invoke.png)





# 总结

Android系统的Binder通信实现了RPC远程调用，BpXXX和BnXXX则负责RPC远程调用的业务，XXX就代表不同的服务业务。BpXXX和BnXXX都实现了IXXX接口，IXXX定义了业务接口函数，BpXXX则是客户进程对服务进程中的BnXXX的影子对象，客户进程在调用服务进程中的某个接口函数时，只需调用BpXXX中的对应函数即可，BpXXX屏蔽了进程间通信的整个过程，让远程函数调用看起来和本地调用一样，这就是Android系统的Binder设计思想。