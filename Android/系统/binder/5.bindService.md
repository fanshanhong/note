---

title: BindService

date: 2021-03-08

categories: 
   - Java

tags: 
   - Java


description: 
​
---

# 概述

在bindService的源码中将要涉及到三个主要的进程，分别是bindService发起端进程，system_server进程和目的端Service进程。



# AIDL

对于Stub，服务实体，它的 asInterface 方法， 如果传入 BinderProxy，就返回一个 Stub 对应的  Proxy。
它的 asBinder 方法返回自己
```java
public static com.example.api.aidl.IAidlFun asInterface(
                android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) && (iin instanceof com.example.api.aidl.IAidlFun))) {
                return ((com.example.api.aidl.IAidlFun) iin);
            }
            return new com.example.api.aidl.IAidlFun.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }
```

对于 Proxy，构造传入 BinderProxy，它的 mRemote 就是 BinderProxy，  它的asBinder 方法就返回这个  mRemote 对象
```java
private static class Proxy implements com.example.api.aidl.IAidlFun {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }
```

对于 Service 进程（服务端），创建 Stub的 对象， 并在 onBind中返回
```java
 @Override
    public IBinder onBind(Intent intent) {
        Log.e(TAG,"onBind");
        return mBindService;
    }
    mBindService= new  BindSercice();
    //此处的IAidlFun.Stub是由编译器自动实现生成的，帮我们快速实现Binder的开发
    public class BindService extends IAidlFun.Stub {
        @Override
        public void doAction() throws RemoteException {
        }
    }
```

发起端进程，也就是客户端进程，调用bindService， 传入Intent 和 一个 接口ServiceConnection。ServiceConnection接口的onServiceConnected方法中，**第二个参数，就是 在 服务端  onBind 方法 返回的 真正执行服务的 XXStub的    服务的远端代理 的  BinderProxy对象。拿到这个远端代理对象，然后通过asInterface方法转成 对应的  XXStub.Proxy， 这样就能RPC调用服务中的方法了。**

```java
      private IAidlFun mRemoteServiceProxy;


    private void bindService() {
        // 发起端进程绑定远程服务端进程
        bindService(new Intent("com.example.aidl.aidlService"), mConnection,
                Context.BIND_AUTO_CREATE);
    }

    ServiceConnection mConnection = new ServiceConnection() {
        @Override
        public void onServiceDisconnected(ComponentName name) {
        }      

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            Log.d(TAG, "onServiceConnected");
            // 获取远程服务端Service代理端Proxy
            mRemoteServiceProxy = IAidlFun.Stub.asInterface(service);

            try {
                // RPC远程服务端方法，实现跨进程交互
                mRemoteServiceProxy.doAction();
            } catch (RemoteException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    };
```


# 流程

ContextImpl.bindService

ContextImpl.bindServiceCommon

```java
//ContextImpl.java
	final LoadedApk mPackageInfo;
    private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler
            handler, UserHandle user) {
        IServiceConnection innerConnection;//这是一个aidl生成的Binder接口类
		...
        if (mPackageInfo != null) {
			//获取的是内部静态类InnerConnection。  是个 Binder 实体  static  InnerConnection extends IServiceConnect.Stub
         // 把这个sd名字换了啊， 太难懂了。就叫 innerConnect。
         //sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);
            innerConnection = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);
        } else {
            ...
        }
        validateServiceIntent(service);//判断参数service的有效性
        try {
			...
			//通过Binder远程调用AMS的bindService方
            int res = ActivityManagerNative.getDefault().bindService(
                mMainThread.getApplicationThread(), getActivityToken(), service,
                service.resolveTypeIfNeeded(getContentResolver()),
                innerConnection, flags, getOpPackageName(), user.getIdentifier());
			...
            return res != 0;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
```
先调用 LoadApk .getServiceDispatcher

```java
//LoadedApk.java
    private final ArrayMap<Context, ArrayMap<ServiceConnection, LoadedApk.ServiceDispatcher>> mServices = new ArrayMap<Context, ArrayMap<ServiceConnection, LoadedApk.ServiceDispatcher>>();

    public final IServiceConnection getServiceDispatcher(ServiceConnection c,
            Context context, Handler handler, int flags) {
        synchronized (mServices) {
            LoadedApk.ServiceDispatcher sd = null;//ServiceDispatcher内部类
            ArrayMap<ServiceConnection, LoadedApk.ServiceDispatcher> map = mServices.get(context);//查找mService中是否存在context的key
            if (map != null) {//如果存在这样的map，则继续查找map中是否存在ServiceConnection类型的实例c的key
                sd = map.get(c);//
            }
            if (sd == null) {//没有则创建
				//创建服务分发对象，注意这里的参数c是ServiceConnection对象
                sd = new ServiceDispatcher(c, context, handler, flags);
                if (map == null) {
                    map = new ArrayMap<ServiceConnection, LoadedApk.ServiceDispatcher>();
                    mServices.put(context, map);
                }
				//以ServiceConnection为key，ServiceDispatcher为value保存到map中
                map.put(c, sd);
            } else {
                sd.validate(context, handler);
            }
			   //返回内部类对象InnerConnection实例
            return sd.getIServiceConnection();
        }
    }
```
其中涉及的一个重要的数据结构对象mServices：

可以看到它是一个Hashmap类型的数据，其key为Context类型对象
然后mServices的value也是一个Hasmap，存放着Context对象所对应的ServiceConnection以及所对应的LoadedApk.ServiceDispatcher对象，即一个Context对象可以对应很多个ServiceConnection，但是同一个只会被创建一次。可以理解，在activity 中，可以bindService多次，每次传一个  ServiceConnect。因此就出现了这个结构： 一个 context， 对应多个  ServiceConnect 。

context 肯定不为空。第一次肯定没找到。因此sd == null的，然后创建 sd（ServiceDispatcher），创建map，以 ServiceConnection 为 key，ServiceDispatcher为value保存到map中。

整体的对应关系

Context - < ServiceConnection - < ServiceDispatcher > > 

Context对 Map 是 一对多。

ServiceConnection 对 ServiceDispatcher ，也是一对多？ 这里好像是一对一的关系。
因此，这里的 这个 mServices，大概是 一个 Context 对一个  元组（ServiceConnection - ServiceDispatcher）。
不管怎么样，最后创建好一个 InnerConnection extends IServiceConnection.Stub 对象，是个Binder 实体。是在ServiceDispatcher 构造中创建好的。

```java
//LoadedApk.java
    static final class ServiceDispatcher {
		   //内部类
        private final ServiceDispatcher.InnerConnection mIServiceConnection;
		   //用户传递的参数
        private final ServiceConnection mConnection;
        private final Context mContext;
        private final Handler mActivityThread;
...

        private static class InnerConnection extends IServiceConnection.Stub {
            final WeakReference<LoadedApk.ServiceDispatcher> mDispatcher;

            InnerConnection(LoadedApk.ServiceDispatcher sd) {
                mDispatcher = new WeakReference<LoadedApk.ServiceDispatcher>(sd);
            }
			//注意这里的入参IBinder实例对象service
            public void connected(ComponentName name, IBinder service) throws RemoteException {
                LoadedApk.ServiceDispatcher sd = mDispatcher.get();
                if (sd != null) {
                    sd.connected(name, service);
                }
            }
        }

        ServiceDispatcher(ServiceConnection conn,
                Context context, Handler activityThread, int flags) {
            //创建InnerConnection对象
            mIServiceConnection = new InnerConnection(this);
			//用户定义的ServiceConnection
            mConnection = conn;
            mContext = context;
            mActivityThread = activityThread;
            mLocation = new ServiceConnectionLeaked(null);
            mLocation.fillInStackTrace();
			//保存用户传递的参数，通常为Context.BIND_AUTO_CREATE
            mFlags = flags;
        }

		//返回内部类对象InnerConnection实例
        IServiceConnection getIServiceConnection() {
            return mIServiceConnection;
        }
```


 通过源码我们发现ServiceDispatcher是LoadedApk的内部类。InnerConnection是ServiceDispatcher的静态内部类。
在 getServiceDispatcher  方法，就是创建或者了一些数据结构，然后返回了InnerConnection extends IServiceConnection.Stub 对象。也就是返回了一个 Binder 实体。



回到 bindServiceCommon  方法， getServiceDispatcher 就到这，继续 ActivityManagerNative.getDefault().bindService(）
```java
            int res = ActivityManagerNative.getDefault().bindService(
                mMainThread.getApplicationThread(), getActivityToken(), service,
                service.resolveTypeIfNeeded(getContentResolver()),
                innerConnection, flags, getOpPackageName(), user.getIdentifier());
```

ActivityManagerNative.getDefault()拿到 ActivityManagerProxy，传入的参数:
1. `mMainThread.getApplicationThread()` 是当前进程的  ApplicationThread 实体（Binder 实体）。当前进程是发起进程
2. innerConnection  是  从 ServiceDispatch 中拿到的  IServiceConnection.Stub 实体对象
都作为 匿名 Binder 传入


然后就会调用 ActivityManagerProxy 的 transact 方法，把数据发送到Binder 驱动。

```java
//ActivityManagerNative.java
    public int bindService(IApplicationThread caller, IBinder token,
            Intent service, String resolvedType, IServiceConnection connection,
            int flags,  String callingPackage, int userId) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
		//写入AMS Binder服务描述信息即android.app.IActivityManager
        data.writeInterfaceToken(IActivityManager.descriptor);
		//写入 IApplicationThread 匿名Binder服务实体(这个在attachApplication时写入过)
		data.writeStrongBinder(caller != null ? caller.asBinder() : null);
        data.writeStrongBinder(token);
...
		//此处写入 IServiceConnection 匿名Binder服务实体
        data.writeStrongBinder(connection.asBinder());
...
		//mRemote指向BinderProxy，而BinderProxy持有C++端的BpBinder，进而借助Binder驱动和AMS通信
        mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0);
...
        return res;
    }
```

经过Binder 驱动传输，进入 ActivityManagerNative的  onTransact方法，进而调用 ActivityManagerNative的bindService方法
```java
//ActivityManagerNative.java
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {
        switch (code) {
        	...
        	case BIND_SERVICE_TRANSACTION: {
	            data.enforceInterface(IActivityManager.descriptor);

               //注意:注意：  readStrongBinder 是根据handle，创建 BpBinder，然后创建 BinderProxy！！
               // 参考 https://cdn.jsdelivr.net/gh/fanshanhong/note-image/readStrongBinder.png

               //拿到第一个 匿名Binder的 远端代理，也就是 IApplicationThread  的代理（BinderProxy）
	            IBinder b = data.readStrongBinder();
				   //此处b为ApplicationThread的代理端，转换后生成即ApplicationThreadProxy对象。现在 app 是 ApplicationThreadProxy对象
	            IApplicationThread app = ApplicationThreadNative.asInterface(b);
	            IBinder token = data.readStrongBinder();
	            Intent service = Intent.CREATOR.createFromParcel(data);
	            String resolvedType = data.readString();
	            b = data.readStrongBinder();//注意这里的b被重新赋值了，拿到 IServiceConnection 的远端代理
	            ..
				   //生成IServiceConnection的代理对象IServiceConnection.Stub.Proxy。现在， conn   是  IServiceConnection.Stub.Proxy
	            IServiceConnection conn = IServiceConnection.Stub.asInterface(b);
	            int res = bindService(app, token, service, resolvedType, conn, fl,
	                    callingPackage, userId);//详见3.2
	            reply.writeNoException();
	            reply.writeInt(res);
	            return true;
        	}
        	...
        }
   }
```

下来调用了 AMN的bindService 方法

```java
//ActivityManagerService.java
	//final ActiveServices mServices;
    public int bindService(IApplicationThread caller, IBinder token, Intent service,
            String resolvedType, IServiceConnection connection, int flags, String callingPackage,
            int userId) throws TransactionTooLargeException {
               // caller 是  ApplicationThreadProxy
               // conn 是  IServiceConnection.Stub.Proxy
		...
        synchronized(this) {
            return mServices.bindServiceLocked(caller, token, service,
                    resolvedType, connection, flags, callingPackage, userId);
        }
    }
```

AMN 转交给了  ActiveServices。看看  ActiveServices 怎么做的


```java
//ActiveServices.java
    int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,
            String resolvedType, final IServiceConnection connection, int flags,
            String callingPackage, final int userId) throws TransactionTooLargeException {
               // caller 是  ApplicationThreadProxy
               // connection 是  IServiceConnection.Stub.Proxy
		...
		//根据第三方进程传递进来的Intent信息来检索相对应的服务，这个retriev单词很契合
		ServiceLookupResult res =
            retrieveServiceLocked(service, resolvedType, callingPackage, Binder.getCallingPid(),
                    Binder.getCallingUid(), userId, true, callerFg, isBindExternal);
      // 没查询到 service， 就返回
       if (res == null) {
            return 0;
        }
        if (res.record == null) {
            return -1;
        }
		   //查询到相应的Service
        ServiceRecord s = res.record;
        if (mAm.mPermissionReviewRequired || Build.PERMISSIONS_REVIEW_REQUIRED) {//权限检测
			...
        }

        try {
            AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);
			   
            //创建对象ConnectionRecord，此处connection来自发起方，把connection 存入 ConnectionRecord
            ConnectionRecord c = new ConnectionRecord(b, activity,
                    connection, flags, clientLabel, clientIntent);

            // connection 是  IServiceConnection.Stub.Proxy ,所以 asBinder 返回的是它的 mRemote， 即 BinderProxy
            IBinder binder = connection.asBinder();
            ArrayList<ConnectionRecord> clist = s.connections.get(binder);

            // 这里解释一下  s.connections。
            // All active bindings to the service.
            // final ArrayMap<IBinder, ArrayList<ConnectionRecord>> connections = new ArrayMap<IBinder,  ArrayList<ConnectionRecord>>();

            // BinderProxy 到 List<ConnectionRecord>的映射
            // 可以理解为  , 我们可以在不同的 Activity 中bindService多次，每次传入不同的回调接口。
            // 不管bind 几次， 通信层 BinderProxy是同一个。
            // 因此， 是 BinderProxy  与  ConnectionRecord 一对多的关系。


            if (clist == null) {
                clist = new ArrayList<ConnectionRecord>();
                s.connections.put(binder, clist);
            }
            clist.add(c);// clist是ServiceRecord.connections的成员变量
         
           ...

            if ((flags&Context.BIND_AUTO_CREATE) != 0) {
                s.lastActivity = SystemClock.uptimeMillis();
				   //启动service，这个过程和startService过程一致
                if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,
                        permissionsReviewRequired) != null) {
                    return 0;
                }
            }

            if (s.app != null) {//此时表示service所属进程已经启动
                if ((flags&Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
                    s.app.treatLikeActivity = true;
                }
                if (s.whitelistManager) {
                    s.app.whitelistManager = true;
                }
                // This could have made the service more important.
                //更新service所在进程优先级
                mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities
                        || s.app.treatLikeActivity, b.client);
                mAm.updateOomAdjLocked(s.app);
            }
				...
            if (s.app != null && b.intent.received) {
                // Service is already running, so we can immediately
                // publish the connection.
                try {
                	//Service已经正在运行，则调用InnerConnection的代理对象
                    c.conn.connected(s.name, b.intent.binder);
                } catch (Exception e) {
                    Slog.w(TAG, "Failure sending service " + s.shortName
                            + " to connection " + c.conn.asBinder()
                            + " (in " + c.binding.client.processName + ")", e);
                }
				...
                //当第一个app连接到该binding, 且之前已被bind过, 则回调onRebind()方法
                if (b.intent.apps.size() == 1 && b.intent.doRebind) {
                    requestServiceBindingLocked(s, b.intent, callerFg, true);
                }
            } else if (!b.intent.requested) {
				   //最终回调onBind()方法
				   requestServiceBindingLocked(s, b.intent, callerFg, false);
            }
            getServiceMap(s.userId).ensureNotStartingBackground(s);

        } finally {
            Binder.restoreCallingIdentity(origId);
        }
        return 1;
    }
```

1. 调用retrieveServiceLocked查找根据第三方进程传递进来的Intent所对应的服务，即系统中是否存在符合intent携带消息的Service。
2. 通过retrieveAppBindingLocked()方法创建AppBindRecord对象，该对象记录着当前ServiceRecord, intent以及发起方的进程ProcessRecord信息
3. BinderProxy 到 List<ConnectionRecord>的映射 存在  ServiceRecord的 connections  Map 里
4. bringUpServiceLocked


```java
private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,
            boolean whileRestarting, boolean permissionsReviewRequired)
            throws TransactionTooLargeException {

		//此种情况前提是要启动的Service所属进程已经创建
		if (r.app != null && r.app.thread != null) {
			//最终调用到目的端Service.onStartCommand()过程，这个过程就不分析了，最后通过ApplicationThreadProxy调用到目的端ActivityThread进而控制目的端Service生命周期执行
            sendServiceArgsLocked(r, execInFg, false);
            return null;
        }
         ...
        //对于进程没有启动的情况下，先启动进程
        if (app == null && !permissionsReviewRequired) {
			//启动service所要运行的进程，这就牵涉到Android应用进程创建的流程了
            if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,
                    "service", r.name, false, isolated, false)) == null) {
                bringDownServiceLocked(r);//进程启动失败处理逻辑
                return msg;
            }
            if (isolated) {
                r.isolatedProc = app;
            }
        }
        return null;


    }
```

前面说过bringUpServiceLocked的启动分为两种情况：

* 当目标进程已存在，则直接执行realStartServiceLocked()；
* 当目标进程不存在，则先执行startProcessLocked创建进程， 经过层层调用最后会调用到AMS.attachApplicationLocked, 然后再执行realStartServiceLocked()


假设不存在，调用  `mAm.startProcessLocked` mAm是 `final ActivityManagerService mAm;`

应该是调用到 Process.start方法，去请求 Zygote 创建进程， 最终在 新创建的目标进程中进入 ActivityThrea.main() 方法

然后  attach()
```java
	//ActivityThread.java
    public static void main(String[] args) {
		...
        ActivityThread thread = new ActivityThread();
        thread.attach(false);//参数false是重点
		...
    }
    final ApplicationThread mAppThread = new ApplicationThread();
    private void attach(boolean system) {
        sCurrentActivityThread = this;
        mSystemThread = system;
        if (!system) {
        	final IActivityManager mgr = ActivityManagerNative.getDefault();
            try {
                mgr.attachApplication(mAppThread);//老套路了啊，远程调用AMS的attachApplication方法，注意这里的参数是IApplicationThread的Binder实体端
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        } else {//不要问我谁会走此分支，我不会告诉你system_server的创建会走此分支的
			...
        }
    }
```
调用 ActivityMamnagerProxy 的 attachApplication 方法， 进入 system_server 进程  AMS.attachApplication。



```java
    //ActivityMangerService.java
    @Override
    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
			   ...
            attachApplicationLocked(thread, callingPid);
            ...
        }
    }

    private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {
           ...
           if (!badApp) {
	            try {
					//寻找所有需要在该进程中运行的服务
	                didSomething |= mServices.attachApplicationLocked(app, processName);//详见3.4.3
	                checkTime(startTime, "attachApplicationLocked: after mServices.attachApplicationLocked");
	            } catch (Exception e) {
	                Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
	                badApp = true;
	            }
        }
        ...         
   	}
```


进入  ActiveService  的  attachAppLocked
```java
//ActiveServices.java
    boolean attachApplicationLocked(ProcessRecord proc, String processName)
            throws RemoteException {
        boolean didSomething = false;
       。。。
					//正常启动service，并开始其的生命周期
                    realStartServiceLocked(sr, proc, sr.createdFromFg);
       }
```

又来到了realStartServiceLocked方法，这个和前面的前后照应了:在 AMS 中的  bringUpServiceLocked 方法奥：

即当需要创建新的进程时候，会调用AMS.startProcessLocked启动进程，然后经过千辛万苦的各种辗转最后调用到attachApplicationLocked方法，进而调用realStartServiceLocked方法

若不用创建进程，则直接调用 realStartServiceLocked 方法，进行剩余工作。


真正的启动是干嘛呢？

```java
//ActiveServices.java
    private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app, boolean execInFg) throws RemoteException {
        ...
		   //发送delay消息,ANR预埋雷
        bumpServiceExecutingLocked(r, execInFg, "create");
         ...

        boolean created = false;
        try {
			...
   			//这里的app.thread是IApplicationThread服务的远程代理客户端，服务进入onCreate
            app.thread.scheduleCreateService(r, r.serviceInfo,
                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                    app.repProcState);//调用到远程服务端onCreate方法
            r.postNotification();
            created = true;
        } catch (DeadObjectException e) {//应用死亡通知
            Slog.w(TAG, "Application dead when creating service " + r);
            mAm.appDiedLocked(app);
            throw e;
        } finally {
           。。。
        }

        if (r.whitelistManager) {
            app.whitelistManager = true;
        }

		//通过bindService方式启动service
        requestServiceBindingsLocked(r, execInFg);

        updateServiceClientActivitiesLocked(app, null, true);
        。。。

		//开启service的生命周期onStartCommand()
        sendServiceArgsLocked(r, execInFg, true);

      }
```


记得我们经常说的Android四大组件中不能执行耗时操作吗，小伙们有想过为什么吗?这是因为有Android ANR的预埋雷机制,关于ANR的机制和原理可以详细参见博客



http://gityuan.com/2016/07/02/android-anr/

在bumpServiceExecutingLocked会发送一个延迟处理的消息SERVICE_TIMEOUT_MSG。在方法scheduleCreateService执行完成，也就是onCreate回调执行完成之后，便会remove掉该消息。但是如果没能在延时时间之内remove该消息，则会进入执行service timeout流程触发ANR，这就是为啥Android 四大组件不能执行耗时操作的原因

看下 这个  bumpServiceExecutingLocked 方法

```java
//ActiveServices.java
    private final void bumpServiceExecutingLocked(ServiceRecord r, boolean fg, String why) {

        long now = SystemClock.uptimeMillis();
        if (r.executeNesting == 0) {
           ...
        } else if (r.app != null && fg && !r.app.execServicesFg) {
            r.app.execServicesFg = true;
            scheduleServiceTimeoutLocked(r.app);//走入该分支
        }
    }
```

```java
//ActiveServices.java
	//前台服务timeout时间为20
    static final int SERVICE_TIMEOUT = 20*1000;
    // 后台服务timeout时间为200s
    static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10;
    void scheduleServiceTimeoutLocked(ProcessRecord proc) {
        if (proc.executingServices.size() == 0 || proc.thread == null) {
            return;
        }
        long now = SystemClock.uptimeMillis();
        Message msg = mAm.mHandler.obtainMessage(
                ActivityManagerService.SERVICE_TIMEOUT_MSG);
        msg.obj = proc;
		   //在超时允许的时间内依然没有remove该SERVICE_TIMEOUT_MSG,则会执行SERVICE_TIMEOUT_MSG流程
         // 使用Handle ，延时发送消息
        mAm.mHandler.sendMessageAtTime(msg,
                proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));
    }
```

 还记得我们老说的Service的ANR超时时间吗，什么前台服务是多少，后台服务是多少，一切的源头都在于此，这里会延时发送消息SERVICE_TIMEOUT_MSG，而这个延时的时间可以看到分为两种情况：

对于前台服务，则超时时间为SERVICE_TIMEOUT，即timeout=20s
对于后台服务，则超时间为SERVICE_BACKGROUND_TIMEOUT，即timeout=200s


注意这里的mAm.mHandler是在AMS中进行处理的，其处理逻辑如下所示：

```java
//AMS.java
final class MainHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
            	...
	            case SERVICE_TIMEOUT_MSG: {
	                if (mDidDexOpt) {
	                    mDidDexOpt = false;
	                    Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
	                    nmsg.obj = msg.obj;
	                    mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);
	                    return;
	                }
	                mServices.serviceTimeout((ProcessRecord)msg.obj);//又调用到ActiveServices中去了
	            } break;   
	            ...         
        	}
        }
}
```

如果在规定时间内，没有把这个消息Message 移除，就收到消息，就代表ANR 了。


埋雷完了之后， 进入 ` app.thread.scheduleCreateService(`。这个 app.thread   是 ApplicationThread的远端代理对象 ApplicationThreadProxy，通过它向新创建的目标进程发消息。

```java
//ApplicationThreadNative.java
    public final void scheduleCreateService(IBinder token, ServiceInfo info,
            CompatibilityInfo compatInfo, int processState) throws RemoteException {
        Parcel data = Parcel.obtain();
        data.writeInterfaceToken(IApplicationThread.descriptor);
        data.writeStrongBinder(token);
        info.writeToParcel(data, 0);
        compatInfo.writeToParcel(data, 0);
        data.writeInt(processState);
        try {
            mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null,
                    IBinder.FLAG_ONEWAY);
        } catch (TransactionTooLargeException e) {
            Log.e("CREATE_SERVICE", "Binder failure starting service; service=" + info);
            throw e;
        }
        data.recycle();
    }
```

进入 目标进程，ApplicationThreadNative 的 onTransact。这个执行在 Binder 线程中

```java
ApplicationThreadNative.java
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {
        switch (code) {
        ..
        case SCHEDULE_CREATE_SERVICE_TRANSACTION: {
            data.enforceInterface(IApplicationThread.descriptor);//常规操作，读取从binder驱动传递过来的业务数据
            IBinder token = data.readStrongBinder();
            ServiceInfo info = ServiceInfo.CREATOR.createFromParcel(data);
            CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data);
            int processState = data.readInt();
            scheduleCreateService(token, info, compatInfo, processState);//由其子类ApplicationThread实现
            return true;
        }
        ...
      }
	}
```

```java
执行  ApplicationThread 的  scheduleCreateService。ApplicationThread 是  ActivityThread 的 内部类
  public final void scheduleCreateService(IBinder token,
                ServiceInfo info, CompatibilityInfo compatInfo, int processState) {
            updateProcessState(processState, false);
            CreateServiceData s = new CreateServiceData();//创建CreateServiceData实例对象，为Service的创建准备数据
            s.token = token;
            s.info = info;
            s.compatInfo = compatInfo;

            sendMessage(H.CREATE_SERVICE, s);
        }
```

在Binder 线程中， 通过Handle 发消息  到主线程。主线程的 handleMessage 中执行
```java
//ActivityThread.java
private class H extends Handler {
	public void handleMessage(Message msg) {
	    switch (msg.what) {
	        ...
	        case CREATE_SERVICE:
	            handleCreateService((CreateServiceData)msg.obj);// onCreate
	            break;
	        case BIND_SERVICE:
	            handleBindService((BindServiceData)msg.obj);//onBind
	            break;
	        case UNBIND_SERVICE:
	            handleUnbindService((BindServiceData)msg.obj);
	            break;
	        case SERVICE_ARGS:
	            handleServiceArgs((ServiceArgsData)msg.obj);  // serviceStart
	            break;
	        case STOP_SERVICE:
	            handleStopService((IBinder)msg.obj);
	            maybeSnapshot();
	            break;
	        ...
	    }
	}
}
```


```java
//AT.java
    private void handleCreateService(CreateServiceData data) {
         ...
        try {
			//通过反射创建目标服务对象
            java.lang.ClassLoader cl = packageInfo.getClassLoader();
            service = (Service) cl.loadClass(data.info.name).newInstance();
        } catch (Exception e) {
            ...
        }
        try {
           ...
			//调用service服务的onCreate()方法
			service.onCreate();
            mServices.put(data.token, service);
            try {
				//调用服务创建完成,将ANR预埋雷除去,看来和AMS的互动很频繁啊
                ActivityManagerNative.getDefault().serviceDoneExecuting(
                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);//详见章节4.5
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        } catch (Exception e) {
           ...
        }
    }
```


反射创建 Service 对象， 执行目的端Service的onCreate方法
调用AMS的serviceDoneExecuting方法，解除在前面预埋的ANR雷，不然真的会爆炸的


看下 AMS 中如何解除ANR 雷的。
```java
//AMS.java
    public void serviceDoneExecuting(IBinder token, int type, int startId, int res) {
        synchronized(this) {
            ...
            //AMS很闲啊，啥也不干全部扔给了ActivityServices处理了，详见4.5.1
            mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);
        }
    }
```

```java
//ActivityServices.java
    void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) {
    	if (r != null) {
    		...
    		final long origId = Binder.clearCallingIdentity();
            serviceDoneExecutingLocked(r, inDestroying, inDestroying);
            Binder.restoreCallingIdentity(origId);
            ...
    	}
    	...
    }
```


```java
private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) {
     //移除服务启动超时的消息，将ANR的雷排除
   mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);
}
```

将消息息SERVICE_TIMEOUT_MSG从Handler的消息队列中移除。分析至此，小伙们应该了解了Service启动过程出现ANR，”executing service [发送超时serviceRecord信息]”，这往往是service的onCreate()回调方法执行时间过长的原因了。





到这说完了 onCreate。
在 前面的  ActiveServices 中  realStartServiceLocked 方法中， 执行完bumpServiceExecutingLocked 和  app.thread.sheduleCreateService 之后  ， 接下来执行
```java
//通过bindService方式启动service
        requestServiceBindingsLocked(r, execInFg);

        updateServiceClientActivitiesLocked(app, null, true);
        。。。

		//开启service的生命周期onStartCommand()
        sendServiceArgsLocked(r, execInFg, true);

````

```java
//ActivityServices.java
    private final void requestServiceBindingsLocked(ServiceRecord r, boolean execInFg)
            throws TransactionTooLargeException {
        for (int i=r.bindings.size()-1; i>=0; i--) {//遍历有多少需要bindings的Service
            IntentBindRecord ibr = r.bindings.valueAt(i);
            if (!requestServiceBindingLocked(r, ibr, execInFg, false)) {//调用另外一个重载的requestServiceBindingLocked方法
                break;
            }
        }
    }

    private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,
            boolean execInFg, boolean rebind) throws TransactionTooLargeException {
         ...
        if ((!i.requested || rebind) && i.apps.size() > 0) {
            try {
				//发送bind开始的消息，又开始埋雷了
                bumpServiceExecutingLocked(r, execInFg, "bind");
                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
				   //服务进入onBind()
				   r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,
                        r.app.repProcState);
                ...
            } catch (TransactionTooLargeException e) {
               ...
            }
        }
        return true;
    }
```

* 调用bumpServiceExecutingLocked方法继续埋雷，倘若目标Service的onBind方法没有在指定的时间内执行完毕，则会触发ANR,这个已经在前面有过详细分析了
* 接着调用目标服务端进程的ApplicationThread代理端ApplicationThreadProxy的方法scheduleBindService，向ApplicationThread发送Binder请求


经过Binder 驱动， 进入  ApplicationThreadNative 的 onTransact 方法中
```java
 @Override
    //ApplicationThreadNative.java
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {
        switch (code) {
        ..
        case SCHEDULE_BIND_SERVICE_TRANSACTION: {
            data.enforceInterface(IApplicationThread.descriptor);
            IBinder token = data.readStrongBinder();
            Intent intent = Intent.CREATOR.createFromParcel(data);
            boolean rebind = data.readInt() != 0;
            int processState = data.readInt();
            scheduleBindService(token, intent, rebind, processState);//在其子类AT中实现该方法
            return true;
        }
        ...
      }
	}
```

调用 ApplicationThread 的  scheduleBindService 方法.ApplicationThread 是定义在  ActivityThread 类中。 他 ActivityThread 的内部类
```java

  public final void scheduleBindService(IBinder token, Intent intent,
                boolean rebind, int processState) {
            updateProcessState(processState, false);
            BindServiceData s = new BindServiceData();//创建BindServiceData实例对象，接收AMS传递过来的Service信息
            s.token = token;
            s.intent = intent;
            s.rebind = rebind;

            sendMessage(H.BIND_SERVICE, s);
        }```

又在Binder 线程发消息，主线程接收消息执行。
主线程执行：
```java
case BIND_SERVICE:
	            handleBindService((BindServiceData)msg.obj);//onBind
```

进入 ActivityThread 的  handleBindService 方法
```java
//AT.java
    private void handleBindService(BindServiceData data) {
        Service s = mServices.get(data.token);
        
        if (s != null) {

                  ...
                    if (!data.rebind) {
						//执行Service.onBind()回调方法，此时在远程服务进程的主线程中
                        IBinder binder = s.onBind(data.intent);
						//将onBinde返回值传递回去，注意这里的binder还是Binder服务端，只有经过Binder传输以后才变成了代理端
						//这里的ActivityManagerNative.getDefault()获取的是AMS的代理端AMP
                        ActivityManagerNative.getDefault().publishService(
                                data.token, data.intent, binder);
                    } else {
                     ...
                    }
                    ensureJitEnabled();

        }
    }
```

注意：现在是在新创建的目标进程中执行的！


执行目的端Service的onBind方法。onBind 会返回一个 Binder实体： binder 。这个就是我们在Service 中 编写的 那个  XXXStub（服务实体）。

ActivityManagerProxy.publishService方法，将把onBind 返回的 那个 服务实体，传给 AMS 去。

后续， AMS 应该会再把 这个 东东，传给 发起进程。感觉是这样， 继续看。



看 ActivityManagerProxy.publishService

```java
//ActivityManagerNative.java
    public void publishService(IBinder token,
            Intent intent, IBinder service) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(token);
        intent.writeToParcel(data, 0);
        // 这个 service 参数， 是 onBind方法的 返回值， 就是真正提供服务的服务实体。
		//将service.onbind的返回值  传递给远端进程，这里写入的是目的服务端的Binder实体对象，经过Binder传输以后会转变成Binder代理端（BinderProxy），并在AMS的内核进程中创建一个binder_ref引用	
        data.writeStrongBinder(service);
        mRemote.transact(PUBLISH_SERVICE_TRANSACTION, data, reply, 0);
        reply.readException();
        data.recycle();
        reply.recycle();
    }
```

经过Binder 驱动， 到了  ActivityManagerNative 的 onTransact 方法中
```java
    @Override
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {
        switch (code) {
             case PUBLISH_SERVICE_TRANSACTION: {
            data.enforceInterface(IActivityManager.descriptor);
            IBinder token = data.readStrongBinder();
            Intent intent = Intent.CREATOR.createFromParcel(data);
            //  这个 service， 是 onBind 返回值 那个真正提供服务的实体对应的 代理的  BinderProxy对象了
            IBinder service = data.readStrongBinder();
            publishService(token, intent, service);
            reply.writeNoException();
            return true;
        }
```

直接 readStrongBinder()拿到  Service， 并传入 publishService。注意， 这个  service ， 是  是 onBind 返回值 那个真正提供服务的实体对应的 代理的  BinderProxy对象了。注意：并不是上层的那个XXStub.Proxy



然后我们看 在  ActivityManagerService 中拿到  这个 Binder 是怎么处理的
```java
//ActivityManagerService.java
    public void publishService(IBinder token, Intent intent, IBinder service) {
       ...
        synchronized(this) {
         ...
            //这里需要关注的是入参service，为目的端IBinder的代理端（BinderProxy）
            //这个mService 是  ActiveService
            mServices.publishServiceLocked((ServiceRecord)token, intent, service);
        }
    }
```

```java
//AS.java
	//注意此处的入参service为我们要启动Service 中 onBind 返回的那个 真正提供服务的实体的 远端代理 的  (BinderProxy)
    void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) {
        ...
        try {
           ...
            if (r != null) {
                Intent.FilterComparison filter
                        = new Intent.FilterComparison(intent);
                IntentBindRecord b = r.bindings.get(filter);
                if (b != null && !b.received) {
                    b.binder = service;
                    b.requested = true;
                    b.received = true;
                     for (int conni=r.connections.size()-1; conni>=0; conni--) {
                        ArrayList<ConnectionRecord> clist = r.connections.valueAt(conni);
                        for (int i=0; i<clist.size(); i++) {
                            ConnectionRecord c = clist.get(i);
                            if (!filter.equals(c.binding.intent.intent)) {
                                if (DEBUG_SERVICE) Slog.v(
                                ...
                                continue;
                            }
                        try {
                                c.conn.connected(r.name, service);
                            } catch (Exception e) {
                               ...
                            }
                        }
                    }
                }
                serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }
```


这里，通过 ServiceRecord 拿到里面的 connections（ArrayMap）， 

双重循环， 遍历里面的每一个 ConnectionRecord，并调用   c.conn.connected(r.name, service);
这个 conn 是之前传入的，c.conn是 发起端进程的IServiceConnection.Stub.Proxy代理对象。
什么时候赋值的？


发起端进程  先bindService， 传入 IServiceConnect.Stub 服务实体。在 AMS 端， onTransact 拿到 BinderProxy， 转成IServiceConnect.Stub.Proxy， 然后再 ActiveServices 的 bindServiceLocked 方法中， 创建 ConnectionRecord的 时候， 放在 ConnecttionRecord中保存


现在我们知道了 c.conn   是  IServiceConnection.Stub.Proxy， 那它调用  connected ，两个参数：
1. 要启动的 Service的名字
2. 参数service，  是 onBind 返回值 那个真正提供服务的实体对应的 代理的  BinderProxy对象了


 最终是调用到  IServiceConnection.Stub  的 connected 中了。
 注意，这里进入了发起端进程。



我们看下IServiceConnection.Stub  的  connected 做了什么

```java
		//LoadedApk.java[InnerConnection]
        private static class InnerConnection extends IServiceConnection.Stub {
            final WeakReference<LoadedApk.ServiceDispatcher> mDispatcher;

            InnerConnection(LoadedApk.ServiceDispatcher sd) {
                mDispatcher = new WeakReference<LoadedApk.ServiceDispatcher>(sd);
            }

            public void connected(ComponentName name, IBinder service) throws RemoteException {
                LoadedApk.ServiceDispatcher sd = mDispatcher.get();
                if (sd != null) {//注意此处的sd为LoadedApk.ServiceDispatcher实例
                    sd.connected(name, service);
                }
            }
        }
```

转去调用   ServiceDispatcher，两个参数， 一个是 要启动的服务名，service 是  要启动的那个服务 onBind 返回值 ，就是那个真正提供服务的实体对应的 代理的  BinderProxy对象了



看下  ServiceDispatcher的 connected
```java
	//LoadedApk.java[ServiceDispatcher]
        public void connected(ComponentName name, IBinder service) {
            if (mActivityThread != null) {//走此分支，mActivityThread不为null，并且这里的mActivityThread是一个Handler不是ActivtyThread,可以从章节2.2看到这个Handler是发起端主线程的Handler
               mActivityThread.post(new RunConnection(name, service, 0));
            } else {
                doConnected(name, service);
            }
        }
```

也就是说， 在主线程执行 RunConnection(name, service, 0)

```java
//LoadedApk.java[RunConnection]
        private final class RunConnection implements Runnable {
            RunConnection(ComponentName name, IBinder service, int command) {
                mName = name;
                mService = service;
                mCommand = command;
            }

            public void run() {
                if (mCommand == 0) {
                    doConnected(mName, mService);
                } else if (mCommand == 1) {
                    doDeath(mName, mService);
                }
            }

            final ComponentName mName;
            final IBinder mService;
            final int mCommand;
        }
```


 doConnected(mName, mService);

 mName指代我们bind的目的端远程Service的组件名对象ComponentName 实例
mService指代我们bind的目的端远程端服务onBind()返回的返回的Binder实体的代理端对象


继续看 ServiceDispatcher 的  doConnected
```java
//LoadedApk.java[ServiceDispatcher]
        public void doConnected(ComponentName name, IBinder service) {
            ...
            if (service != null) {
				//回调用户的onServiceConnected方法
                mConnection.onServiceConnected(name, service);
            }
        }
```

直接回调了用户传入的 ServiceConnection 接口的  onServiceConned 方法。并把参数丢进去， 第一个参数是mName指代我们bind的目的端远程Service的组件名对象ComponentName 实例，第二个参数是：mService指代我们bind的目的端远程端服务onBind()返回的真正提供服务的远端代理的 BinderProxy对象


到这里，我们就能理解了：为啥每次 onServiceConnected  中都要调用一下  asInterface 方法。
```java
 ServiceConnection mConnection = new ServiceConnection() {
        @Override
        public void onServiceDisconnected(ComponentName name) {
        }      

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            Log.d(TAG, "onServiceConnected");
            // 获取远程服务端Service代理端Proxy
            mRemoteServiceProxy = IAidlFun.Stub.asInterface(service);

            try {
                // RPC远程服务端方法，实现跨进程交互
                mRemoteServiceProxy.doAction();
            } catch (RemoteException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    };
```

显然， 这块返回的  service 参数， 指代我们bind的目的端远程端服务onBind()返回的真正提供服务的远端代理的 BinderProxy对象。我们必须调用一下 对应的 asInterface 方法， 把它转成  XXStub.Proxy 对象， 才能正常的调用RPC。

```java
```java
public static com.example.api.aidl.IAidlFun asInterface(
                android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) && (iin instanceof com.example.api.aidl.IAidlFun))) {
                return ((com.example.api.aidl.IAidlFun) iin);
            }
            //传入 BinderProxy， 不进if， 直接走这里！
            return new com.example.api.aidl.IAidlFun.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }
```

这样就完了。



# 小结

===发起端进程！

bindService  传入conn 接口

创建一个 ServiceDispatcher 对象
conn 放在 ServiceDispatcher 里
并且，在ServiceDispatcher 中还创建了一个 private static class InnerConnection extends IServiceConnection.Stub

我们就叫： IServiceConnection.Stub


还有个 ApplicationThread 实体

东西创建好后， 调用 AMP.bindService，把这两个匿名Binder 都传进去


====system_server进程


AMN.bindService
拿到 IApplicationThread 的 BinderProxy对象， 转成 ApplicationThreadProxy对象
拿到 IServiceConnection 的 BinderProxy 对象， 转成IServiceConnection.Stub.Proxy


把一些东西存入 ServiceRecord、
把IServiceConnection.Stub.Proxy 存入 ConnectionRecord

完了之后，创建新的进程。


======新创建的目标进程 

attachApplication


====== system_server进程
通知 目标进程  onCreate

====目标进程 
onCreate


====== system_server进程
通知目标进程onBind

====目标进程
回调 onBind

onBind返回值是真正用来提供服务的 Binder实体  XXStub。


把这个  XXStub 发到 system_server进程去。

====system_server
拿到XXStub对应的  BinderProxy


然后通过之前保存的 IServiceConnection.Stub.Proxy 调用发起进程的 connected方法


====发起进程
回调接口的 onServiceConnected 方法。


总结：

0.  发起进程  和 目标进程不直接通信， 全部依赖 system_server进程

1. Conn 接口，发起进程自己存。等远端（AMS）调。
   IApplicationThread 给 AMS（在这个过程好像没用这个？）
   IServiceConnection.Stub  给了 AMS


2. AMS 持有 ApplicationThreadProxy 和 IServiceConnection.Stub.Proxy

3. 创建新进程，通知新进程各种回调

3. 新进程执行onBind， 就能拿到 真正用来提供服务的 Binder实体  XXStub。
把XXStub 给AMS


4. AMS 通过之前保存的  IServiceConnection.Stub.Proxy 调用发起进程的 connected方法

5. 发起端进程 回调接口的 onServiceConnected 方法。






从进程交互角度出发
* 发起端进程: 首先通过bindService携带接口回调类ServiceConnection传递到LoadedApk中，接着在该类中通过getServiceDispatcher获取发起端进程的匿名Binder服务端(此为第一处匿名Binder)，即LoadedApk.ServiceDispatcher.InnerConnection,该对象继承于IServiceConnection.Stub；再通过bindService调用到system_server进程
* system_server进程: 依次通过scheduleCreateService和scheduleBindService方法, 远程调用到目的端进程进程(这里的前提是目的端进程已经创建，如果服务端进程还没有创建，则还牵涉到目的服务端进程的创建)
* 目的端进程: 依次执行目的端Service的onCreate()和onBind()方法;，然后将onBind()方法的返回值IBinder(作为目的端进程匿名的Binder服务端，此处为第二处匿名Binder服务端)，接着通过publishService将该匿名Binder服务端的代理端传递到system_server进程
* system_server进程: 经过上述的一系列处理以后，利用IServiceConnection代理对象向发起端进程发起connected()调用, 并把target进程的onBind返回Binder对象的代理端传递到发起端进程
* 发起端: 回调到onServiceConnection()方法, 该方法的第二个参数便是目的端进程的Binder代理端. 到此便成功地拿到了目的端进程的代理, 可以畅通无阻地进行RPC交互了


